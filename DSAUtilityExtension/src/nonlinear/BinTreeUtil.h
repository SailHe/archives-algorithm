#pragma once
#include "../stdafx.h"
#include "../DSAUEdll.h"

namespace Tree {
	// 遍历的顺序类型枚举
	enum TraversalOrderEnum {
		ORDER_PREFIX_ROOT, // 先根序
		ORDER_INFIX_ROOT, // 中根序
		ORDER_POST_ROOT, // 后根序
		ORDER_LEVEL, // 层序
	};
	enum TreeImplTypeEnum {
		// 线性内存块 Virtual Linked
		LinearBlock,
		// 非线性内存块 Real Linked
		NonlinearBlock,
	};
	template<typename T>
	int Min(T a, T b) {
		return a < b ? a : b;
	}
	template<typename T>
	int Max(T a, T b) {
		return a > b ? a : b;
	}
	//数组表
	template<typename T> using ArrayList = std::vector<T>;
	template<typename T> using stack = std::stack<T>;
	template<typename T> using queue = std::queue<T>;
	template<typename T> using priority_queue = std::priority_queue<T>;
	template<typename T> using greater = std::greater<T>;
	using string = std::string;
	//template<typename T> using vector = StandardExtend::ArrayList<T>;
}

// 二度树效用工具集
namespace BinTreeUtil {

	// 二叉树结点
	template<typename T>
	class BinTreeNode {
	public:
		typedef T Element;
		BinTreeNode() {}
		// 获取子类height字段
		virtual int getHeight() {
			// return depthOf(this);
			return -1;
		}
		// 设置子类height字段
		virtual void setHeight(int) {}
		// 获取子类的添加字段:weight (曾考虑过在这里添加字段 并重载比较符号 但极容易引起误会以及存在其它很多劣势故作罢)
		virtual int getValue() {
			return 0;
		}
		// 设置子类添加字段
		virtual void setValue(int) {}

		// 这样无需默认构造函数
		BinTreeNode(Element const&tData) : Data(tData) {}
		// 拷贝构造 仅拷贝数据 子结点置nullptr
		BinTreeNode(BinTreeNode &rhs) {
			(*this) = rhs;
			Left = Right = nullptr;
		}
		virtual ~BinTreeNode() {
			DE_PRINTF("BinTreeNode析构");
		}
		// 赋值 默认的全域赋值
		BinTreeNode &operator=(const BinTreeNode&) = default;

		int height() {
			// return depthOf(this);
			return -1;
		}
		// 叶子结点判断
		bool isLeave() const {
			return Left == nullptr && Right == nullptr;
		}

		// 指向左子树
		BinTreeNode* Left = nullptr;
		// 指向右子树
		BinTreeNode* Right = nullptr;
		// 表示是否visit过此结点
		bool v = false;
		// 结点数据:若为结构体,结构体提供比较方法key(增删查都会使用的关键字)在结构体内 否则key就是Data weight-height不能作为key(不唯一)
		Element Data;

	};



	// 结点管理类
	// (简单粗暴的实现的话可以直接判断语句判断 但这样会在类内部再次添加至少1个域: cap, 而且并非所有子类都会使用 因此采用继承方式)
	template<typename T>
	class NodeManager {

	public:
		typedef typename BinTreeUtil::BinTreeNode<T> *Position;
		// 结点生成器 返回一个未使用的结点 若不存在未使用结点 返回nullptr 只能插入使用
		virtual Position nodeCreater(T const &tData) = 0;
		// 结点擦除器 将结点置为未使用状态
		virtual void nodeEraser(Position &del) = 0;
		// 返回已创建的结点数
		int createdNodeNum() {
			return nodeBlockCounter;
		}
		NodeManager() {}
		virtual Tree::TreeImplTypeEnum getTreeImplType() = 0;
		virtual ~NodeManager() {}

	protected:
		// 结点块计数器
		int nodeBlockCounter = 0;
	};

	// [完全]结点分配器 (完全: 与完全二叉树的完全二字定义一致)
	template<typename T>
	class CompleteNodeManager :public NodeManager<T> {

	public:
		typedef typename BinTreeUtil::BinTreeNode<T> *Position;
		typedef typename BinTreeUtil::BinTreeNode<T> const *Block;
		typedef typename Position NodeArray;
		using NodeManager<T>::nodeBlockCounter;
		CompleteNodeManager(int nSize) : capacity(nSize) {
			momoryPool = new BinTreeUtil::BinTreeNode<T>[nSize];
		}
		virtual ~CompleteNodeManager() override {
			delete[] momoryPool;
			momoryPool = nullptr;
		}

		Position nodeCreater(T const &tData) override {
			Position newNode = nullptr;
			if (full()) {
				// DNT
			}
			else {
				newNode = position(nodeBlockCounter);
				newNode->Data = tData;
				++nodeBlockCounter;
			}
			return newNode;
		}
		void nodeEraser(Position &del) override {
			if (del != nullptr) {
				// 解除其连接关系
				del->Left = del->Right = nullptr;
				// 假删
				del = nullptr;
				--nodeBlockCounter;
			}
		}
		void clear() {
			nodeBlockCounter = 0;
		}
		int index(Block b) const {
			return b - momoryPool;
		}
		bool full() const {
			return nodeBlockCounter == capacity;
		}
		// 返回数组内的结点位置
		Position position(int sub) {
			assert(0 <= sub && sub < capacity);
			return momoryPool + sub;
		}
		Tree::TreeImplTypeEnum getTreeImplType() override {
			return Tree::LinearBlock;
		}
		
		BinTreeUtil::BinTreeNode<T> &operator[](int i) {
			assert(0 <= i && i < capacity);
			return momoryPool[i];
		}

	private:
		// '内存'池: Left和Right储存左右孩子位于池内的地址 Varrays
		NodeArray momoryPool = nullptr;
		// '内存'池容量 | 最多元素个数 | 结点个数   至少为1
		int capacity = 0;
	};

	// 非线性结点分配器 其分配的内存是没有规律的
	template<typename T>
	class NonLinearNodeManager :public NodeManager<T> {

	public:
		typedef typename NodeManager<T>::Position Position;
		using NodeManager<T>::nodeBlockCounter;

		NonLinearNodeManager() {}
		Tree::TreeImplTypeEnum getTreeImplType() override {
			return Tree::NonlinearBlock;
		}
		// virtual ~NonLinearNodeManager() override {}
		Position nodeCreater(T const &tData) override {
			++nodeBlockCounter;
			return new BinTreeUtil::BinTreeNode<T>(tData);
			/*
			bST = (BST)malloc(sizeof(struct TNode));
			memset(bST, 0, sizeof(struct TNode));
			bST->Element = x;
			*/
		}
		void nodeEraser(Position &del) override {
			// malloc就应用memeset初始化free释放 new自动初始化 赋值初始化 delete释放
			// free(del); del = nullptr;
			delete del;
			del = nullptr;
			--nodeBlockCounter;
		}

	private:
	};

	// 线性结点分配器 分配仍没有规律 但使用数组作为一块'虚拟内存' 分配效率[可能]略高 (结点关系: 与CompleteNodeManager同属于虚拟链接)
	// class LinearNodeManager
	// queue<Element*> freeBlock; // 空闲块
	// Element *blockPool = nullptr; // 块池

	// must know inorder

	/*根据先序和中序遍历输出后序遍历序列 (先 中 后 子树元素个数)*/
	void calcPostOrder(Tree::string const &sPre, Tree::string const &sMed, Tree::string &sPostBuffer);
	template<class Iterator>
	// 支持加减运算的迭代器(裸指针也行 postOder对应的容器必须具有至少n个元素)
	void calcPostOrder(Iterator preOrder, Iterator inOrder, Iterator postOder, int n) {
		int Ln;/*左子子树长度*/
		if (n == 0)return;
		postOder[n - 1] = *preOrder;/*转化关系:先序遍历数组的首元素就是子树根*/
		for (Ln = 0; Ln < n && inOrder[Ln] != *preOrder; ++Ln);
		calcPostOrder(preOrder + 1, inOrder, postOder, Ln);/*先序遍历数组向左子树遍历一个元素 其余数组保持不变*/
		calcPostOrder(preOrder + Ln + 1, inOrder + Ln + 1, postOder + Ln, n - Ln - 1);/*向右子树遍历一个元素*/
	}
	template<class Element>
	void calcPostOrder(Element *preOrder, Element *inOrder, Element *postOder, int n) {
		int Ln;/*左子子树长度*/
		if (n == 0)return;
		postOder[n - 1] = *preOrder;/*转化关系:先序遍历数组的首元素就是子树根*/
		for (Ln = 0; Ln < n && inOrder[Ln] != *preOrder; ++Ln);
		calcPostOrder(preOrder + 1, inOrder, postOder, Ln);/*先序遍历数组向左子树遍历一个元素 其余数组保持不变*/
		calcPostOrder(preOrder + Ln + 1, inOrder + Ln + 1, postOder + Ln, n - Ln - 1);/*向右子树遍历一个元素*/
	}

	/*根据后序和中序遍历输出先序遍历序列 只修改中间两句话即可*/
	template<class Iterator>
	void calcPrefOrder(Iterator preOrder, Iterator inOrder, Iterator postOder, int n) {
		int Ln;/*左子树长度*/
		if (n == 0)return;
		*preOrder = postOder[n - 1];/*转化关系:后序遍历数组的尾元素就是子树根*/
		for (Ln = 0; Ln < n && inOrder[Ln] != postOder[n - 1]; ++Ln);//获取左子树长度
		calcPrefOrder(preOrder + 1, inOrder, postOder, Ln);/*先序遍历数组进入左子树*/
		calcPrefOrder(preOrder + Ln + 1, inOrder + Ln + 1, postOder + Ln, n - Ln - 1);/*进入右子树*/
	}
	template<class Element>
	void calcPrefOrder(Element *preOrder, Element *inOrder, Element *postOder, int n) {
		int Ln;/*左子树长度*/
		if (n == 0)return;
		*preOrder = postOder[n - 1];/*转化关系:后序遍历数组的尾元素就是子树根*/
		for (Ln = 0; Ln < n && inOrder[Ln] != postOder[n - 1]; Ln++);//获取左子树长度
		calcPrefOrder(preOrder + 1, inOrder, postOder, Ln);/*先序遍历数组进入左子树*/
		calcPrefOrder(preOrder + Ln + 1, inOrder + Ln + 1, postOder + Ln, n - Ln - 1);/*进入右子树*/
	}

	/*根据后序和中序遍历输出层序遍历序列 后中->先->先序建树->层序遍历*/
	template<class Element>
	void calcLeveOrder(Element *preOrder, Element *inOrder, Element *postOder, int n) {
		_ASSERT_EXPR(false, "has not impl");
		exit(-1);
	}
}
