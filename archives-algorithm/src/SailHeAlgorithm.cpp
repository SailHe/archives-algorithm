#include "SailHeAlgorithm.h"
//#include<bits/stdc++.h> //包涵了几乎所有文件
/*__int64 I64d
Rows = r;Cols  = c;//报表行列数
1s 一般可以执行 10 ^ 7 次操作
DP:动态规划
D:\LaberDate\
字体测试
XxKkIiLl 10 oO{}{}
Pp
lllll
11111
*
/************逆向*****0*********45*******90*********135*******180********225*******270********315****/
//int dir[8][2] = { { 1, 0 }, { 1, 1 }, { 0, 1 }, { -1, 1 }, { -1, 0 }, { -1, -1 }, { 0, -1 }, { 1, -1 } };
const int Dir8[8][2] = { { 1, 0 }, { 1, -1 }, { 0, -1 }, { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, 1 }, { 1, 1 } };
const int Dir4[4][2] = { { 0, -1 /*左*/ }, { 0, 1 /*右*/ }, { -1, 0 /*上*/ }, { 1, 0 /*下*/ } };

//非聚合  点类
class MyPoint{
public:
	double x, y;
	MyPoint() = default;
	MyPoint(double x, double y){
		x = y, y = y;
	}
	MyPoint(istream &in){
		//scanf("%lf%lf", &(this->x), &(this->y));
		in >> this->x >> this->y;
	}
	MyPoint O(){
		MyPoint O = { 0.0, 0.0 };
		return O;
	}
};


//返回两点间距离
double dDistance(MyPoint const &p1, MyPoint const &p2){
	double dx = p2.x - p1.x;
	double dy = p2.y - p1.y;
	return sqrt(dx*dx + dy*dy);
}
//返回由p1, p2, p3组成的三角形的面积
double dTriangleArea(MyPoint const &p1, MyPoint const &p2, MyPoint const &p3){
	double d12 = dDistance(p1, p2)
		, d13 = dDistance(p1, p3)
		, d23 = dDistance(p2, p3);
	//海伦公式
	double dL = (d12 + d13 + d23) / 2.0;
	return sqrt(dL * (dL - d12) * (dL - d13) * (dL - d23));
}
//若点p位于p1, p2, p3组成的三角形内那么返回true 否则返回false
bool isInternalTriangle(MyPoint const &p1, MyPoint const &p2, MyPoint const &p3, MyPoint const &p){
	double a12p = dTriangleArea(p1, p2, p)
		, a13p = dTriangleArea(p1, p3, p)
		, a23p = dTriangleArea(p2, p3, p)
		, a123 = dTriangleArea(p1, p2, p3);
	//被那个点分割出的所有面积块之和与三角形总面积在误差范围内相等时 则在三角形内部 精度过高可能会被坑 一般1E-5即可
	return (fabs(a123 - (a12p + a13p + a23p)) < EPS);
}

void testForTriangle(){
	//freopen("input", "r", stdin);
	MyPoint p1, p2, p3, p;
	while (8 == scanf("%lf%lf%lf%lf%lf%lf%lf%lf"
		, &p1.x, &p1.y
		, &p2.x, &p2.y
		, &p3.x, &p3.y
		, &p.x, &p.y)){
		puts(isInternalTriangle(p1, p2, p3, p) ? "Yes" : "No");
	}
}


/*在一行中打印出二进制的n。递归实现。*/
void dectobin(int n)
{
	if (n < 2)
		printf("%d", n);
	else
	{
		dectobin(n / 2);
		printf("%d", n % 2);
	}
}
/* 以eps为精度用 三分法 求函数F在[L, R]的最小值 */
double divThree(double L, double R, double eps, double(*F)(double))
{
	double Ll, Rr;
	while (R - L > eps)
	{
		Ll = (2 * L + R) / 3;/* 三分 */
		Rr = (2 * R + L) / 3;
		if (F(Ll) > F(Rr))
			L = Ll;
		else
			R = Rr;
	}
	return F(L);/* 返回任一个即可 */
}/* 练习题HDU2899 */
/* 返回是否符合勾股定理 */
int pythTriangle(int a, int b, int c)
{
	return a*a == b*b + c*c || b*b == a*a + c*c || c*c == a*a + b*b;
}
//ans为s1+s2(s1与s2的并集)(直接ans.push_back(temp)即可没必要建实际生物s1与s2)
//返回s1与s2并集的中位数, ans为s1+s2(直接push_back即可) a0,a1,a2...an-1的中位数指a[(n-1)/2] (共n个数)即第(n+1)/2个数(a0为第一个数)
int median(vector<int> ans){
	sort(ans.begin(), ans.end());
	if (ans.size() % 2 == 0)
		return ans[ans.size() / 2 - 1];
	else
		return ans[ans.size() / 2];
}
/*汉诺塔递归解法*/
void move(int n, char a, char b, char c)
{/* Move(n,'A','B','C');*/
	if (n == 1)
		printf("%c To %c\n", a, c);    //当n只有1个的时候直接从a移动到c
	else
	{
		move(n - 1, a, c, b);            //第n-1个要从a通过c移动到b
		printf("%c To %c\n", a, c);
		move(n - 1, b, a, c);            //n-1个移动过来之后b变开始盘，b通过a移动到c，这边很难理解
	}
}
/*大数整除判断*/
int divisible(char *Bigint, int MOD)
{
	int len = strlen(Bigint);
	int ans, i;
	for (ans = i = 0; i < len; i++){
		ans = (ans * 10 + (Bigint[i] - '0')) % MOD;
	}
	return ans == 0 ? true : false;
}
/*清空输入流直至遇到end字符*/
void refresh(char end)
{
	while (getchar() != end);
}
/*两点间距离*/
double dis(MyPoint a, MyPoint b)
{
	return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));
}
/*起点-终点-跳跃能力-活动半径*/
int jump(MyPoint s, MyPoint e, double Power, double R)
{
	return dis(s, e) <= R + Power;
}
//引用实现 易爆
void swapMy(int &a, int &b)
{
	a += b;
	b = a - b;
	a = a - b;
}
//返回与参数的时间差（单位：小时）
double getDifftime(time_t t_start)
{
	time_t t;
	double all;
	time(&t);
	all = difftime(t, t_start);
	return all / 3600;
	/*
	clock_t Start = clock();
	clock_t Stop = clock();
	printf("矩阵乘法执行时间：%lf\n", (double)(Stop - Start)/CLK_TCK);
	*/
}
/*返回错排表 最大26个*/
__int64* illArrange()
{
	__int64 *M = (__int64*)malloc(26 * sizeof(__int64));
	M[0] = 0, M[1] = 1, M[2] = 1;
	for (int n = 3; n < 26; n++)
		M[n] = (n - 1) * (M[n - 1] + M[n - 2]);
	return M;
}
/*矩阵乘法 Product = Product*a两矩阵不能相同*/
void matrixMultiply(const int n, int(*a)[25], int Product[][25]/*矩阵积*/)
{
	int r, c, i, tmp;
	int b[25][25];
	memcpy(b, Product, n*25 * 4);
	for (r = 0; r < n; r++)
	{
		for (c = 0; c < n; c++)
		{
			for (tmp = i = 0; i < n; i++)//行列遍历对应相乘 累加给tmp 再赋给 Product
				tmp += a[r][i] * b[i][c];
			Product[r][c] = tmp;
		}
	}
}

//输出digit中lhs到rhs的全排列  非字典序
void penetration(char *digit, int lhs, int rhs){
	if (lhs == rhs)
		puts(digit);
	else{
		for (int i = lhs; i <= rhs; i++){
			swap(digit[lhs], digit[i]);
			penetration(digit, lhs + 1, rhs);
			swap(digit[lhs], digit[i]);
		}
	}
}
/*输出数字1-n的全排列*/
void pentration(int n){
	char digit[11] = "123456789";
	digit[n] = '\0';
	//penetration(digit, 0, n - 1);
	do{
		puts(digit);//求下一个排列数 #include<algorithm>
	} while (next_permutation(digit, digit + n));
	digit[n] = n + '0';
}
//反转maxR行的二维数组a 每行位于区间[列cSt,列cEn)的元素
void reversal(int a[][105], int cSt, int cEn, int maxR = 1) {
	for (int r = 0; r < maxR; r++) {
		for (int c = cSt, i = 0; i < (cEn - cSt) / 2; i++, c++){
			int temp = a[r][c];
			a[r][c] = a[r][cEn - i - 1];
			a[r][cEn - i - 1] = temp;
		}
	}
}
/*将R行 C列的二维数组向左移k位*/
void leftMoveK(int a[][105], int R, int C, int k){
	/*
	8 3
	1 2 3 4 5 6 7 8
	8 7 6 5 4/ 3 2 1
	4 5 6 7 8/ 1 2 3
	*/
	k %= C;
	reversal(a, 0, C, R);/*反转所有元素*/
	reversal(a, 0, C - k, R);/*反转前C-k个元素*/
	reversal(a, C - k, C, R);/*反转后k个元素*/
}
/*右移k位<==>左移C-k位 leftMoveK(a, R, C, C-k); <==> rightMoveK(a, R, C, k);*/
void rightMoveK(int a[][105], int R, int C, int k){
	/*
	8 3
	1 2 3 4 5 6 7 8
	8 7 6/ 5 4 3 2 1
	6 7 8/ 1 2 3 4 5
	*/
	k %= C;
	reversal(a, 0, C, R);
	reversal(a, 0, k, R);/*反转前k个元素*/
	reversal(a, k, C, R);/*反转后C-k个元素*/
}
//逆序数
int Reverse(int number)
{
	int temp = number;
	int sum = 0, product = 1;
	int top = 0;
	int temptop;
	for (top = 0; temp != 0; temp /= 10, top++);
	//for (top = 1; temp /= 10; top++);
	temp = number;
	while (temp != 0)
	{
		temptop = top-- - 1;
		product = 1;
		while (temptop-- != 0)
		{
			product *= 10;
		}
		sum += (temp % 10) * product;
		temp /= 10;
	}
	return sum;
}
//返回数字x中D出现的次数
int digitCountD(const int x, const int D)
{
	int temp = x;
	int count = 0;
	do
	{
		count += ((temp % 10) > 0 ? (temp % 10) : -(temp % 10)) == D ? 1 : 0;
		temp /= 10;
	} while (temp != 0);
	return count;
}
//获取整数的位数
int digitTop(int number)
{
	int top = 1;
	while (number /= 10)top++;
	return top;
}
//删除res中的字符字串del
void delssInS(char *res, char *del)
{
	int i, res_len, del_len;
	char *p;
	del_len = strlen(del);
	res_len = strlen(res);

	for (p = strstr(res, del); p != NULL; p = strstr(res, del))
	{
		for (i = p - res; i < res_len - del_len + 1; i++)
		{
			res[i] = res[i + del_len];
		}
		res_len = strlen(res);
	}
}
/*计算第一个最长连续递增子序列(longest continuous increment sequence)*/
//返回长度 参数:用于储存最长连续子序列的区间[lhs, rhs)
size_t lonConIncSeq(const vector<int> a, int &lhs, int &rhs){
	int maxLen = 0, n = a.size();
	lhs = 0, rhs = -1;//rhs==-1使计算其初是长度时为0
	for (int l = 0, r = 0, len = 0;; ++r){
		len = r - l + 1;
		maxLen = rhs - lhs + 1;
		/*更新最长递增子列 (第一个子序列:不取等)*/
		if (len > maxLen){
			lhs = l, rhs = r;
		}
		else{}
		if (r >= n - 1)
			break;//r < n - 1 保证n==1时正确
		if (a[r] < a[r + 1]){}
		//当前子列不是递增子列
		else{
			l = r + 1;//重置局部递增子列
		}
	}
	++rhs;
	return maxLen;
}
/*********************************************排 序********************************************************/

/*qsort(a, 排序长度, 一个元素的大小, intCmp);*/
template<class CmpType>
int lessQsortCmp(const void *min, const void *max)
{
	return ((CmpType*)min)->year - ((CmpType*)max)->year;
}
template<class CmpType>
int structCmp(const void *min, const void *max)
{
	int cp = ((CmpType*)min)->value - ((CmpType*)max)->value;//按主价值 从小到大排序
	if (cp == 0)
		cp = ((CmpType*)max)->value2 - ((CmpType*)min)->value2;//按次价值 从大到小排序
	return cp;
}
/*sort(a, a+n, boolCmp)*/
template<class CmpType>
bool lessSortCmp(CmpType min, CmpType max)
{
	return min.value < max.value;
}
//冒泡排序

void BubbleSort(int a[], int n, int K, int cmp(const void *a, const void *b))
{
	int temp = 0;//对数组a中的n个元素进行的第K次
	for (int i = 0; i < K; i++)//K代表遍数时不能减一
	{
		for (int j = 0; j < n - i - 1; j++)//此处必须减一
		{
			if (cmp(&a[j + 1], &a[j]))
			{
				temp = a[j + 1];
				a[j + 1] = a[j];
				a[j] = temp;
			}
		}
	}
}
//选择排序
template<class CmpType>
void SlectSort(CmpType a[], CmpType *an, int(*cmp)(CmpType *a, CmpType *b))
{
	for (; a < an - 1; a++)
	{
		for (CmpType *j = a + 1; j < an; j++)
		{
			if (cmp(j, a))
			{
				swap(*a, *j);
			}
		}
	}
}
/*********************************************查 找********************************************************/
//二分查找re[n]中key
int dichotomy(int re[], int n, int key) {
	sort(re, re + n);
	int left = 0, right = n, mid = 0;
	while (left <= right) {
		mid = (right + left) / 2;
		if (re[mid] < key) {
			left = mid + 1;
		}//加1之前若确认mid不合法, 于是可以把这个结果用到下一次的计算中, 若不加1下一次可能会重新计算mid
		else if (re[mid] > key){
			right = mid - 1;/**同上**/
		}
		else{
			return mid;
		}
	}
	return -1;
}
/*二分枚举+贪心*/
int canJump(int s[], int n, int m, int jump)
{
	int step = 0;
	int from = 0;
	int to = 1;
	int out = true;
	while (to < n)//到达终点时结束
	{
		out = true;
		while (to < n && s[to] - s[from] <= jump)
		{
			to++;//贪心，通过尽可能多的石头
			out = false;
		}
		from = to - 1;
		step++;
		if (out || step > m)//说明jump小了，有的地方跳不过去  || 步数过多
			return false;
	}
	return true;
}
int st[5/*00002*/];
int main_1_()
{
	int L, M, N;
	while (cin >> L >> N >> M)
	{
		N += 2;
		st[0] = 0;
		for (int i = 1; i < N - 1; scanf("%d", &st[i++]));
		sort(st + 1, st + N - 1);
		int left = st[1];
		int right = st[N - 1] = L;
		st[0] = 0;
		while (left < right)
		{
			int mid = (left + right) >> 1;
			if (canJump(st, N, M, mid))//若可以在小于m步的前提下跳过去 那么尝试小一些的jump力,但要保留上一次的jump值：mid不减1
				right = mid;
			else//在无法跳过的前提下，mid值无需保留
				left = mid + 1;
		}
		cout << left << endl;
	}
	return 0;
}
/*********************************************DATE********************************************************/
//闰年判断
int isIntercalary(int year)
{
	return (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);
}
//计算这天是当前年份的第几天
int today(int year, int month, int day)
{
	int t, j, month_day[2][13] = {
		{ 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
		{ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 } //闰年
	};
	for (t = j = 0; j < month; t += month_day[(year % 4 == 0 && year % 100 != 0 || year % 400 == 0)][j++]);
	return t + day;
}
//返回t1与t2间的分数时间差min， 并将小时，min结果存于参数指针中  t格式08:05 ==>805
int timeDiffrence(int t1, int t2, int *t_h, int *t_min)
{
	if (t1 % 100 <= t2 % 100)
	{
		*t_h = t2 / 100 - t1 / 100;
		*t_min = t2 % 100 - t1 % 100;
	}
	else
	{
		*t_h = t2 / 100 - t1 / 100 - 1;
		*t_min = t2 % 100 - t1 % 100 + 60;
	}
	return *t_h * 60 + *t_min;
}
/*********************************************数 学********************************************************/
/*卡塔兰数*/
I64* catalanTable(){
	/*定义式式:fact(2 * n) / (fact(n + 1) * fact(n))若有除法,会导致精度不足.引起不可逆的错误*/
	/*递归式1: C(n)=((4*n-2)/(n+1))*C(n-1);此题该递归式会爆*/
	int maxN = 36;
	I64 *cata = (I64*)malloc(maxN*sizeof(I64));
	memset(cata, 0, maxN * sizeof(I64));//C(i)=0必须初始化
	cata[0] = cata[1] = 1;
	/*递归式2:C(0)=1, C(1)＝1, n>=2时, C(n)= C(0)*C(n-1) + ... +C(i)*C(n-i-1) + ... + C(n-1)C(0)*/
	for (int n = 2; n < maxN; n++){
		for (int i = 0; i < n; i++)
			cata[n] += cata[i] * cata[n - i - 1];
	}
	return cata;
}
//tmp = pow(iNum, 2)的后面几位 待研究func
int f(int iNum, int m){
	int tmp = 0;
	for (long long w = m; w > 0; w /= 10)
	{
		long long d = (iNum / w - (iNum / (10 * w)) * 10)*w;
		long long e = iNum % (10 * m / w);
		tmp += (d*e);
	}
	return tmp;
}
/**************************************************************************/
__int64 Quickfact(__int64 a, __int64 b, __int64 mod)
{
	__int64 ans = 0;
	while (b)
	{
		if (b & 1)
		{
			ans = (ans + a) % mod;
		}
		a = (a << 1) % mod;
		b >>= 1;
	}
	return ans;
}
__int64 Quickpow(__int64 C, __int64 R, __int64 k)
{
	__int64 ans = 1;
	while (R > 0)
	{
		R & 1 ? ans = Quickfact(ans, C, k) : ans;
		C = Quickfact(C, C, k);
		R >>= 1;
	}
	return ans;
}
//快速幂简易版 m^n % k（k）
I64 quickPow(I64 m, I64 n, I64 k)
{
	I64 ans = 1;
	while (n > 0)
	{
		n & 1 ? ans = ((ans%k)*(m%k)) % k : ans;
		m = ((m%k)*(m%k)) % k;
		n >>= 1;
	}
	return ans;
}
I64 quickPow(I64 m, I64 n)
{
	I64 ans = 1;
	while (n > 0){
		//n & 1 ? ans = ans*m : ans;
		if (n & 1)
			ans *= m;
		m *= m;
		n >>= 1;
	}
	return ans;
}
/*任意底数对数*/
double logR(double value, double base = 5) {
	return log(value) / log(base);
}
/*阶 乘*/
double fact(int n){
	double product = n;
	while (--n > 0)product *= n;
	return n == 0 ? 1 : product;//0的阶乘为1
}
//int 限度内阶乘表
int* factTable(int maxN = 13)/*int 13!爆； double和long long int 18!爆*/{
	int *Fact = (int *)malloc(sizeof(int)* maxN);
	Fact[0] = Fact[1] = 1;
	for (int n = 2; n < maxN; ++n) 
		Fact[n] = Fact[n - 1] * n;
	return Fact;
}
/*
n < m && m != 0
	 fact(n)
 ________________
fact(n - m) * fact(m)
*/
//组合数
int C(int n, int m){
	int f = 1, i = 1;
	f = n - m < 0 ? 0 : f;//n < m时c(n,m) = 0
	m = n - m < m ? n - m : m;//int 防爆n30 m29时   c(30, 29) = c(30, 1)
	while (i <= m)
	{
		f *= n--;//n * (n - 1) * ...m
		f /= i++;//1 *    2    * ...m
	}
	return f;
}
//排列数
int A(int n, int m)
{
	int d, f = 1;
	for (d = n - m; d < n && d >= 0; --n)
	{
		f *= n;
	}
	return f;
}
//生成n行 的杨辉三角
void buildPtriangle(int n, int table[][30])
{
	table[0][0] = 1;
	for (int r = 1; r < n; r++)
	{
		//每行的数字个数=行数+1(行数从0开始)
		//若需要每行前面的空格的话 每行第一个数字前面的空格数 = 2*[(maxR-currentR(1开始))的那一行的数字数]  ==> 2*(n-r-1)
		//int blakCnt = 0;
		for (int c = 0; c < r + 1; c++)
		{
			if (c != 0)
				table[r][c] = table[r - 1][c] + table[r - 1][c - 1];
			else
				table[r][c] = table[r - 1][c];
		}
	}
}
//打印n行的杨辉三角
void PrintPtriangle(int n, int table[][30])
{
	for (int pr = 0; pr < n; pr++)
	{
		for (int pc = 0; pc < n; pc++)
		{
			if (table[pr][pc] != 0)
				printf("%d", table[pr][pc]);
			if (pc < pr)
			{
				printf(" ");
			}
			else if (pc == pr && pr != n - 1)
				puts("");
		}
	}
	puts("\n");
}

//辗转相除求公约数, 互素(互质)判定
int gcd(int a, int b)
{
	return b == 0 ? a : gcd(b, a % b);
}
/*
扩展的欧几里得算法（辗转相除法）Extended Euclidean algorithm:
功能:
	已知整数a、b, 在求得a、b的最大公约数的同时, 可找到满足贝祖等式ax + by = gcd(a, b)的整数x、y;（也称裴蜀数, 其中一个很可能是负数）
若a是负数，可以把问题转化成|a|(-x) + by = gcd(|a|, b)，然后令 x' = (-x)
	利用定理求线性方程的解*//*
返回值      :最大公 约数,因数,因子 gcd(greatest common divisor) 或 hcf(highest common factor)
已知参数a, b:任意非负整数(若是负数可能要更新算法)
返回参数x, y:贝祖数 或 模逆元...
*//*
贝祖等式(裴蜀定理)大意:两数的最大公约数的倍数可以用两数的整数倍相加来表示
关于未知数x和y的方程 ax + by = m有整数解<==>m是d的倍数。(d是任意整数a、b的最大公约数)
裴蜀等式有解时必然有无穷多个整数解，每组解x y都称为裴蜀数，可用扩展欧几里得算法求得。
应用:
对于不定整数方程ax+by=c，若c 是 gcd(a,b)的整数倍则该方程存在整数解
否则不存在 x , y 整数解。
讨论是否存在一整数k，使得m在k圈后比n大一；就是求解： k*m - n = 1;是否有解
1 % gcd(m,n) == 0
*/
int gcdEx_(int a, int b, int &x, int &y){
	if (b == 0){
		x = 1;
		y = 0;
		return a;
	}
	else{
		int g = gcdEx_(b, a%b, x, y);
		int t = x;
		x = y;
		y = t - (a / b)*y;
		return g;
	}

}
//扩展欧几里得算法精简正式版
int gcdEx(int a, int b, int &x, int &y){
	if (b == 0){
		x = 1; y = 0;
		return a;
	}
	int g = gcdEx(b, a%b, y, x);
	y -= a / b*x;
	return g;
}
I64 gcdEx(I64 a, I64 b, I64 &x, I64 &y){
	if (b == 0){
		x = 1; y = 0;
		return a;
	}
	I64 g = gcdEx(b, a%b, y, x);
	y -= a / b*x;
	return g;
}
/*
定理一(贝祖定理)：ax + by = gcd(a, b)必有整数解
定理二：若gcd(a, b) = 1，则方程ax ≡ c (mod b)在[0, b-1]上有唯一解.
证明:对于方程 ax + by = c
<==> ax ≡ c (mod b)			==> 若方程存在特解x,那么x + k*b还是方程的解
定理三：若gcd(a, b) = g，则方程ax ≡ c (mod b)在[0, b/g - 1]上有唯一解.
证明:对于方程 a/g*x+b/g*y = c/g	(若x,y是整数解; g = gcd(a, b) ==> 方程左边是个整数 ==> 右边也该是整数 ==> 否则x,y不是整数解)
<==> a/g*x ≡ c/g (mod b/g)	==> 若方程存在特解x,那么x + k*(b/g)还是方程的解
*/
//pku1061-青蛙的约会
//求线性方程ax+by = c的最小非负整数解x(只能保证x满足条件) 若整数解不存在返回false
int linearEquation(I64 a, I64 &x, I64 b, I64 &y, I64 c){
	I64 x0, y0,
		g = gcdEx(a, b, x0, y0);
	if (c%g != 0)
		return false;
	I64 rx = b / g;
	x = x0*c / g;
	x = (x%rx + rx) % rx;
	//while (x < 0 && rx > 0) x += rx; x %= rx;
	y = (c - a*x) / b;
	return true;
}
//PKU2142-HDU1356-The Balance
/*
定理：对于方程ax+by = c
通解:	x = x0 + b*t
y = y0 - a*t
(①:x0, y0为方程的一组解; ②:gcd(a, b) = 1; ③:t为任一整数.)

①:	g = gcdEx(a, b, x0, y0);
x0 = x0*c / g;
y0 = y0*c / g;
②:	x = x0 + b / g*t
y = y0 - a / g*t
于是		|x|+|y| = |x0+b/g*t| + |y0-a/g*t|
易知		|x0+b/g*t|单调递增，|y0-a/g*t|单调递减.
若规定	a>b
那么		原函数为先减后增的凹图像 (当t满足y0 - a/g*t == 0 时取最小值)
即		|x|+|y| 在t = y0*g/a 附近(③)取最小值
*/
//求线性方程ax+by = c 使得|x|+|y|最小的一组解x,y
void linearEquation(int a, int &x, int b, int &y, int c){
	int hasSwap = false;
	if (a < b) swap(a, b), hasSwap = true;
	I64 x0, y0;
	int g = gcdEx(a, b, x0, y0);
	x0 = x0*c / g;
	y0 = y0*c / g;
	int tB = y0*g / a;
	x = infinity / 2, y = x;
	FOR(t, tB - 5, tB + 5){
		int xT = x0 + b / g*t;
		int yT = y0 - a / g*t;
		if (abs(xT) + abs(yT) < abs(x) + abs(y)){//此处取等则错
			x = xT;
			y = yT;
		}
	}
	if (hasSwap) swap(x, y);
}
/*
modulo inverse
功能:返回a的模m逆元t, 不存在打印错误并结束程序;
a*modInv(a, m) % m = 1
因为at%m=1：要求余数2的话，2*at，要求余数为3的话，3*at
定义

同余号 ≡: 若一个正整数除两个整数 得相同余数，则称二整数[同余]。
同余关系(离散数学):aRb <==> a与b用m除时具有相同的余数r, 此时, 称m是模数, 记a≡b(mod m); (modulo); 读作:a与b模m同余
同余关系是一个[等价关系]:自反,对称,传递

同余类(congruence class或residue class):由对于模n同余的所有整数组成的一个集合; 若从上下文知道模n，则也可标记为[a]。
同余类的代表数(representative):同余类中的拿来代表该同余类的任一元素

模逆元: t ≡ a^(-1)(mod m) 或 at ≡ 1(mod m); 若at与1模m同余, 则t是a的对同余m的模逆元, 也叫做模m的数论倒数;
若ax + my = 1 <==> (1 ≡ 1) ax+my ≡ 1 ≡ ax(mod m) ==> ax ≡ 1; 根据定义, x即是a关于模m的一个模逆元。
*/
int modInv(int a, int m){
	int t, y;
	if (gcdEx(a, m, t, y) != 1) {
		cerr << a << " " << m << "不互素 模逆元不存在!" << endl;
		exit(-1);
	}return t;
}
/*
中国剩余定理: ans = sum(a[i] * t[i] * M[i])
+ k*ans(在模mP的意义下方程组只有ans一个解)
返回值:满足同时%模数组分别等于余数组的整数num
已知参数m:模数组(要求m中任两数互质, 无参数检查)
已知参数a:余数组(强参数)				num%m[i] = r[i]
num模m[i]同余代表数组(弱参数)	num ≡ a[i](mod m[i])
经典问题:
物不知数(xx数之x就是模数), 生理周期(周期是模数 上一次外显的日期是同余代表数)
*/
int chineseReminder(int *m, int *a, int n, int mP = 0){
	int ans, t, y, i;
	if (mP == 0)//避免重复计算, 但是在必须多次计算的地方又可以选择默认参数, 更具灵活性
	for (i = 0, mP = 1; i < n; i++) mP *= m[i];//求m[i]的积mProduct
	for (i = 0, ans = 0; i < n; i++){
		gcdEx(mP / m[i], m[i], t, y);//求M[i] = mP / m[i]的模逆元t[i](极可能为负)
		ans += (a[i] * t * (mP / m[i]));
	}
	ans = (ans + mP) % mP;//ans极有可能为负数
	return ans;
}

//素数(质数)判断
int isPrime_(int num)
{
	double k = sqrt((double)num);
	int i = 0;
	for (i = 2; i <= k && num % i != 0; i++);
	return i > k && num > 1 ? true : false;
}
//素数(质数)判断 sqrt的平方优化版(未实测)
bool isPrime(int num){
	int i = 0;
	for (i = 2; i*i <= num && num % i != 0; i++);
	return i*i > num && num > 1;
}
//真因子和(除本身外的约数）
int factorSum(int x)
{
	int sum = 1, i;//1对应x  只加1不加x
	assert(x != 0);//0没有因子
	for (i = 2; i * i <= x; i++)//i可能爆
	{
		if (x % i == 0)
		{
			sum += i;
			sum += i == x / i ? 0 : x / i;//根号x只加一次
		}
	}//（因子包括1但不包括本身，特别的0没有因子，1的因子为1）；另外因子和为本身的叫完数
	return sum;
}
//真因子和表(约数 因数) (10^7一千万2.51s)(400w 10^6 900ms)
void factorSumTableSieve(const int maxn, int a[/*maxn*/])
{
	for (int i = 1; i < maxn; i++)
	{
		for (int j = i + i; j < maxn; j += i)
		{
			a[j] += i;
		}
	}
}
//素数(质数) 筛选法 埃拉托色尼(Sieve Eratosthenes)(0 1==-1, a[i]==0表示素数) PS:maxN = 1e7时超过1s了 1e9似乎无法分配内存
int* primeSieve(const int maxN = 2) {
	int *prime = (int*)malloc(maxN*sizeof(int));
	memset(prime, 0, maxN*sizeof(int));
	prime[0] = prime[1] = -1;
	for (int i = 2; i < maxN; i++){
		for (int j = i + i; j < maxN; j += i){
			prime[j] += i;
		}
	}
	return prime;
}
//因子数目
int factorCount(int x)
{
	int i, count = 0;
	double k = sqrt((double)x);//1 对应 x 计2   k对应k 计1
	for (i = 1; i <= k; i++)
	{
		if (x % i == 0)
			count += i * i == x ? 1 : 2;//除因子k外   其余因子成对出现
	}
	return count;
}

//开方函数
double sqrtMy(double x, double eps = 1e-9)/*精度*/
{
	double last, next;
	for (last = 1, next = 2;;)
	{
		last = next;
		next = (last + (x / last)) / 2;
		if (fabs(next - last) < eps)
		{
			return next;/*????*/
		}
	}
	return -1;
}
//求方差
double variance(float x[], int n)
{

	double aver, sum = 0, D = 0;
	int temp, i;
	temp = n;
	while (temp-- != 0)
	{
		sum += x[temp];
	}
	aver = sum / n;
	for (i = 0; i < n; i++)
	{
		D += (x[i] - aver) * (x[i] - aver) / n;
	}
	return D;
}
// 欧拉函数:在数论中用于求解[1,n]中与n 互质数 的个数 的函数
int  Eular(int n)
{
	//通式：φ(x) = x(1-1/p1)*(1-1/p2)*(1-1/p3)…(1-1/pn)
	//其中p1,p2……pn为x的所有互异质因数(质因子)，x是不为0的整数。
	int i, ret = n;
	double k = sqrt((double)n);
	for (i = 2; i <= k; i++)
	{
		if (n%i == 0)
		{
			ret = ret / i*(i - 1);
			while (n%i == 0)
				n /= i;
		}
	}
	n > 1 ? ret = ret / n*(n - 1) : 0;
	return ret;
}
//巴什博弈：取最后一个的人胜
int BaShen(int n, int min, int max)
{
	int situation = n % (max + min);
	if (0 < situation && situation <= min)
		return 0;//先手负
	else
		return 1;//先手胜
}
//返回n条边时最大交点数目
int pointLine(int n)
{
	return n*(n - 1) / 2;
}

/************************************************背包**********************************************************/
//01背包 V是背包总容量
void zoback(int V, int back[], int cost, int value)
{
	for (int v = V; v >= cost; v--)
	{
		back[v] = max(back[v], back[v - cost] + value);
	}
}
//01背包数量记法 V是背包总容量  参数value = 0; back[0] = 1;
void ZOBack(int V, int back[], int cost, int value)
{
	for (int v = cost; v <= V; v++)
	{
		back[v] += back[v - cost] + value;
	}
}
void CompletePack(int dp[], int m, int cost, int weight)   //多重背包
{
	for (int i = cost; i <= m; i++)
	dp[i] = max(dp[i], dp[i - cost] + weight);
}
void ZeroOnePack(int dp[], int m, int cost, int weight)   // 01背包
{
	for (int i = m; i >= cost; i--)
		dp[i] = max(dp[i], dp[i - cost] + weight);
}
void MultiplyPack(int dp[], int cost, int m, int weight, int amount)   //完全背包
{
	if (cost*amount >= m)
	CompletePack(dp, m, cost, weight);
	else
	{
		int k = 1;
		while (k<amount)
		{
			ZeroOnePack(dp, m, k*cost, k*weight);
			amount -= k;
			k <<= 1;
		}
		ZeroOnePack(dp, m, amount*cost, amount*weight);
	}
}
/************************************************贪心**********************************************************/
/*密里根油滴实验程序*/
void MiLIGen(double u, double v1)
{
	printf("Q = %f e-19\n", (1e19*3.16e-8*5e-3 / u*pow(v1, 1.5)));
}

/*返回子串s1与s2匹配的字符数 比较长度len)*/
int matching(char *s1, char *s2, int len)
{
	int i, count;
	for (i = count = 0; s1[i] && s2[i] && len--; i++)
	{
		s1[i] == s2[i] ? count++ : 0;
	}
	return count;
}

class Fraction {
	double up = 0;//分子
	double dw = 0;//分母
public:
	Fraction(int up, int dw) {
		this->up = up;
		this->dw = dw;
	}

	Fraction(double up, double dw) {
		this->up = up;
		this->dw = dw;
	}

	~Fraction(){
		//printf("已析构");
	}

	static Fraction ZERO() {
		return Fraction(0, 1);
	}

	static int gcd(int a, int b) {
		return a % b == 0 ? b : gcd(b, a % b);
	}

	double getUp() {
		return up;
	}

	void setUp(double up) {
		this->up = up;
	}

	double getDw() {
		return dw;
	}

	void setDw(double dw) {
		this->dw = dw;
	}

	void plash(Fraction *a) {
		this->up *= a->dw;
		this->up += a->up * this->dw;
		this->dw *= a->dw;
		//Fraction::~Fraction();
		delete a;
	}

	void toSimple() {
		/**公倍数*/
		int Ga = gcd((int) this->up, (int) this->dw);
		this->up /= Ga;
		this->dw /= Ga;
	}

	double toDouble() {
		if (dw == 0)
			throw dw;
		return this->up / this->dw;
	}
};